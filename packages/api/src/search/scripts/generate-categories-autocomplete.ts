/*
 * Soliguide: Useful information for those who need it
 *
 * SPDX-FileCopyrightText: ¬© 2025 Solinum
 *
 * SPDX-License-Identifier: AGPL-3.0-only
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published
 * by the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
// scripts/translateCategories.ts
import "../../config/database/connection";
import { GoogleGenAI } from "@google/genai";
import {
  AutoCompleteType,
  CountryCodes,
  SearchSuggestion,
  SoliguideCountries,
  SupportedLanguagesCode,
} from "@soliguide/common";
import { CONFIG } from "../../_models";
import { SearchSuggestionModel } from "../models/search-suggestion.model";

interface TranslationResult {
  sourceId: string;
  lang: SupportedLanguagesCode;
  seoTitle: string;
  seoDescription: string;
  synonyms: string[];
}

type SearchSuggestionForTranslation = Pick<
  SearchSuggestion,
  | "sourceId"
  | "label"
  | "seoDescription"
  | "synonyms"
  | "type"
  | "categoryId"
  | "lang"
>;

const LANGUAGE_NAMES: Record<SupportedLanguagesCode, string> = {
  [SupportedLanguagesCode.AR]: "arabe",
  [SupportedLanguagesCode.CA]: "catalan",
  [SupportedLanguagesCode.EN]: "anglais",
  [SupportedLanguagesCode.ES]: "espagnol",
  [SupportedLanguagesCode.FA]: "farsi",
  [SupportedLanguagesCode.KA]: "g√©orgien",
  [SupportedLanguagesCode.PS]: "pachto",
  [SupportedLanguagesCode.RO]: "roumain",
  [SupportedLanguagesCode.RU]: "russe",
  [SupportedLanguagesCode.UK]: "ukrainien",
  [SupportedLanguagesCode.FR]: "fran√ßais",
};

class CategoryTranslationScript {
  private readonly genAI: GoogleGenAI;
  private readonly results: TranslationResult[] = [];

  constructor() {
    if (!CONFIG.GEMINI_API_KEY) {
      return;
    }
    this.genAI = new GoogleGenAI({
      apiKey: CONFIG.GEMINI_API_KEY,
    });
  }

  async run() {
    console.log("üöÄ D√©marrage traduction automatique des cat√©gories...");

    // Get french Categories
    const categories = await this.getCategories();

    for (const suggestion of categories) {
      console.log(
        `\nüåç Traduction de: ${suggestion.label} en ${
          LANGUAGE_NAMES[suggestion.lang]
        }`
      );
      try {
        const langTranslation = await this.translateCategory(suggestion);
        console.log({ langTranslation });
        console.log({ sourceId: suggestion.sourceId, lang: suggestion.lang });

        await SearchSuggestionModel.updateOne(
          { sourceId: suggestion.sourceId, lang: suggestion.lang },
          {
            seoTitle: langTranslation.seoTitle,
            seoDescription: langTranslation.seoDescription,
            synonyms: langTranslation.synonyms,
          },
          { upsert: true }
        );

        this.results.push(langTranslation);
      } catch (error) {
        console.error(
          `  ‚ùå Erreur ${suggestion.label} en ${
            LANGUAGE_NAMES[suggestion.lang]
          }:`,
          error.message
        );
      }
    }
  }

  private async getCategories(): Promise<
    Array<SearchSuggestionForTranslation>
  > {
    const categories = await SearchSuggestionModel.find({ seoTitle: "" });

    return categories.map((doc) => ({
      sourceId: doc.sourceId,
      label: doc.label,
      seoDescription: doc.seoDescription || "",
      synonyms: doc.synonyms || [],
      type: doc.type,
      lang: doc.lang,
      categoryId: doc.categoryId,
    }));
  }

  private async translateCategory(
    suggestion: SearchSuggestionForTranslation
  ): Promise<TranslationResult> {
    const prompt = this.buildPrompt(suggestion);

    const response = await this.genAI.models.generateContent({
      model: "gemini-2.0-flash-001",
      contents: prompt,
    });

    if (response) {
      const text = response.text as string;
      return this.parseResponse(text, suggestion);
    } else {
      throw new Error("NO RESPONSE");
    }
  }

  private buildPrompt(
    suggestion: SearchSuggestionForTranslation,
    country?: SoliguideCountries
  ): string {
    const getContentTypeContext = (type: AutoCompleteType): string => {
      switch (type) {
        case AutoCompleteType.ORGANIZATION:
          return `ORGANISME sp√©cifique (${suggestion.label}) - utilisateurs cherchent cette organisation pr√®s de chez eux`;

        case AutoCompleteType.ESTABLISHMENT_TYPE:
          return `TYPE D'√âTABLISSEMENT (${suggestion.label}) - utilisateurs cherchent ce type d'√©tablissement pr√®s de chez eux`;

        case AutoCompleteType.CATEGORY:
          return `CAT√âGORIE d'aide sociale (${suggestion.label}) - utilisateurs cherchent de l'aide dans ce domaine`;

        default:
          return `RECHERCHE LIBRE (${suggestion.label}) - informations sur ce sujet`;
      }
    };

    const needsSynonyms = suggestion.type === AutoCompleteType.CATEGORY;
    const jsonFormat = `{
  "seoTitle": "Titre SEO optimis√©",
  "seoDescription": "Description 150-160 chars avec g√©olocalisation"${
    needsSynonyms ? ',\n  "synonyms": ["terme1", "terme2"]' : ""
  }
}`;

    // Instructions langue et pays
    const langInstruction =
      suggestion.lang && suggestion.lang !== SupportedLanguagesCode.FR
        ? `\nIMPORTANT: Traduis tout dans la langue suivante: ${
            LANGUAGE_NAMES[suggestion.lang]
          }.`
        : "";

    const countryInstruction =
      country && country !== CountryCodes.FR
        ? `\nAdapte pour ${country} (organismes locaux, terminologie du pays).`
        : "";

    return `Expert SEO + FALC pour Soliguide (plateforme de lieux solidaires).

PUBLIC: Personnes pr√©caires, sans-abri, r√©fugi√©s, professionnels sociaux
CONTEXTE: ${getContentTypeContext(suggestion.type)}

Nom: "${suggestion.label}"
Description: "${suggestion.seoDescription || "Non d√©finie"}"
Pays: ${country || CountryCodes.FR}

R√àGLES:
- Mots simples, phrases courtes (max 22 mots)
- √âviter jargon administratif
- Utiliser "vous", ton bienveillant et direct
- √ätre concret avec exemples

OBLIGATIONS:
- Titre: PUNCHY et DIRECT, adapter selon le contexte √©motionnel. Utiliser "${
      suggestion.label
    }" naturellement. Mentionner "Soliguide". PAS de ":" dans le titre. Language direct et engageant.
- Description: "Soliguide" + 3 EXEMPLES CONCRETS d'aide + g√©olocalisation (150-160 chars)${
      needsSynonyms ? "\n- Synonymes: 8-12 termes courants" : ""
    }

EXEMPLES DE TITRES PUNCHY SELON LE CONTEXTE:
- Sant√©: "Trouvez des soins gratuits avec Soliguide"
- Logement: "Trouvez de l'aide au logement avec Soliguide"
- Addiction: "Probl√®mes d'addiction ? Des structures sp√©cialis√©es sont l√† pour vous aider"
- Alimentation: "Ne restez plus sans manger, Soliguide vous aide"
- Emploi: "D√©crochez un travail, formez-vous avec Soliguide"
- Urgence sociale: "Besoin d'aide maintenant ? Soliguide vous trouve des solutions"

EXEMPLES DE DESCRIPTIONS AVEC 3 EXEMPLES CONCRETS:
- "Soliguide trouve pr√®s de chez vous : m√©decin gratuit, dentiste solidaire, infirmerie. Soins accessibles sans avance de frais."
- "Soliguide vous aide : h√©bergement d'urgence, logement social, aide au loyer. Solutions logement pr√®s de chez vous."

EXEMPLES D'√âTABLISSEMENTS:
- "CCAS pour votre domiciliation"
- "Maison de sant√© pr√®s de chez vous"${langInstruction}${countryInstruction}

R√âPONDS UNIQUEMENT AVEC LE JSON BRUT, AUCUN TEXTE AVANT OU APR√àS. COMMENCE DIRECTEMENT PAR { ET TERMINE PAR }:
${jsonFormat}`;
  }

  private parseResponse(
    text: string,
    suggestion: SearchSuggestionForTranslation
  ): TranslationResult {
    try {
      // Nettoyer le texte
      let cleanText = text.trim();

      // Supprimer les balises de code si pr√©sentes
      cleanText = cleanText.replace(/```json\s*|```\s*/g, "");

      // Extraire le JSON entre les premi√®res { et derni√®res }
      const firstBrace = cleanText.indexOf("{");
      const lastBrace = cleanText.lastIndexOf("}");

      if (firstBrace === -1 || lastBrace === -1 || firstBrace >= lastBrace) {
        throw new Error("Format JSON invalide - accolades manquantes");
      }

      const jsonText = cleanText.substring(firstBrace, lastBrace + 1);
      const parsed = JSON.parse(jsonText);

      console.log("‚úÖ JSON pars√©:", parsed);

      if (!parsed.seoTitle || !parsed.seoDescription) {
        throw new Error(
          "Champs manquants dans la r√©ponse JSON (seoTitle et seoDescription requis)"
        );
      }

      const result: TranslationResult = {
        sourceId: suggestion.sourceId,
        lang: suggestion.lang,
        seoTitle: parsed.seoTitle.trim(),
        seoDescription: parsed.seoDescription.trim(),
        synonyms: [],
      };

      // Add synonyms only for categories
      if (suggestion.type === AutoCompleteType.CATEGORY) {
        if (!parsed.synonyms || !Array.isArray(parsed.synonyms)) {
          throw new Error(
            "Les synonymes sont requis et doivent √™tre un tableau pour les cat√©gories"
          );
        }
        result.synonyms = parsed.synonyms.filter(
          (s: string) => s && s.trim().length > 0
        );
      } else {
        result.synonyms = suggestion.synonyms || [];
      }

      return result;
    } catch (error) {
      console.error("‚ùå R√©ponse Gemini brute:", text);
      console.error("‚ùå Erreur de parsing:", error.message);
      throw new Error(`Impossible de parser le JSON: ${error.message}`);
    }
  }

  private delay(ms: number): Promise<void> {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
}

async function main() {
  try {
    const script = new CategoryTranslationScript();
    await script.run();
    process.exit(0);
  } catch (error) {
    console.error("‚ùå Erreur fatale:", error);
    process.exit(1);
  }
}

if (require.main === module) {
  main();
}

export { CategoryTranslationScript };
