import fs from "node:fs";
import path from "node:path";
import { loadCategoriesDsl } from "../dsl/loadCategoriesDsl";

/**
 * Generates Caddy redirect rules using map syntax
 */
function generateCaddy() {
  const dsl = loadCategoriesDsl(path.join(__dirname, "../categories.dsl.yaml"));

  const lines: string[] = [];

  lines.push("# AUTOGENERATED FILE — DO NOT EDIT");
  lines.push("# Old categories redirections");
  lines.push(
    "# Using {http.request.orig_uri.path} because {path} matches /index.html",
  );
  lines.push(
    "map {http.request.orig_uri.path} {category_source} {category_target_path} {",
  );

  // Collect all redirections
  const redirections: Array<{ oldSlug: string; newSlug: string }> = [];

  for (const [, category] of Object.entries(dsl.categories)) {
    for (const entry of category.history) {
      // If the entry has an `until`, it means it's an old slug
      // Only create a redirection if the old slug is different from the current slug
      // to avoid infinite redirect loops
      if (entry.until && entry.slug !== category.slug) {
        redirections.push({
          oldSlug: entry.slug,
          newSlug: category.slug,
        });
      }
    }
  }

  // Sort alphabetically by oldSlug for readability
  redirections.sort((a, b) => a.oldSlug.localeCompare(b.oldSlug));

  // Generate redirection lines
  for (const { oldSlug, newSlug } of redirections) {
    lines.push(
      `\t~^(.*/search/.*)/(${oldSlug})(.*)$ "\${2}" "\${1}/${newSlug}\${3}"`,
    );
  }

  lines.push("}");

  const outputPath = path.join(
    __dirname,
    "../../../frontend/caddy/category-redirects.caddy",
  );

  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  fs.writeFileSync(outputPath, lines.join("\n") + "\n");

  console.log("✅ Caddy file generated");
}

generateCaddy();
