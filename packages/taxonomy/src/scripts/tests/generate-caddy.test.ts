import { describe, it, expect } from "vitest";
import fs from "node:fs";
import path from "node:path";

describe("generate-caddy script", () => {
  it("generates redirections for historical slugs", async () => {
    const generatedFile = path.join(
      __dirname,
      "../../generated/category-redirects.caddy"
    );

    if (fs.existsSync(generatedFile)) {
      fs.unlinkSync(generatedFile);
    }

    await import("../generate-caddy");

    const content = fs.readFileSync(generatedFile, "utf-8");

    // Verify the structure of the generated file
    expect(content).toContain("# AUTOGENERATED FILE â€” DO NOT EDIT");
    expect(content).toContain("# Old categories redirections");
    expect(content).toContain("map {http.request.orig_uri.path} {category_source} {category_target_path} {");
    expect(content).toMatch(/\t~\^.*\$/);

    // Verify that old categories are redirected to new ones
    expect(content).toContain('~^(.*/search/.*)/(sante)(.*)$ "${2}" "${1}/health${3}"');
    expect(content).toContain('~^(.*/search/.*)/(depistage)(.*)$ "${2}" "${1}/std_testing${3}"');

    // Verify that there are no infinite redirect loops
    // (a slug redirecting to itself)
    const lines = content.split('\n');
    const redirectLines = lines.filter(line => line.includes('~^'));

    for (const line of redirectLines) {
      // Extract oldSlug and newSlug from the regex pattern
      const match = line.match(/~\^.*\/\(([^)]+)\)\(.*\$.*\$\{1\}\/([a-z_]+)/);
      if (match) {
        const oldSlug = match[1];
        const newSlug = match[2];
        expect(oldSlug).not.toBe(newSlug);
      }
    }
  });
});
